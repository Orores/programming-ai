[
    {
        "role": "system",
        "content": "You are a machine that turn High Level Software Design into Medium Level Class Design and nothing else."
    },
    {
        "role": "user",
        "content": "Show me a Medium Level Design for a python class that accomplished following High Level Software design:\n\n1. Input: The code changes are extracted from the current git working directory using a git diff command. The changes are tokenized into individual words using a natural language processing (NLP) library.\n\n2. NLP Analysis: The NLP library processes the tokenized words to identify keywords, context, and sentiment within the code changes. This analysis helps in understanding the purpose and impact of the code changes.\n\n3. Proposal: Based on the NLP analysis, a proposed commit message is generated summarizing the code changes. The commit message includes relevant keywords and provides a concise description of the changes made.\n\n4. User Interaction: The proposed commit message is displayed to the user along with the option to accept or reject it. If the user accepts the proposed message, the code changes are staged and committed using the git commit command. If the user rejects the message, they have the option to manually enter a custom commit message.\n\n5. Error Handling: In case of errors during the NLP analysis or if the proposed commit message is not suitable, appropriate error messages are displayed to the user. The user can then choose to retry the NLP analysis or provide a custom commit message."
    },
    {
        "role": "assistant",
        "content": "import git\nimport nltk\n\nclass GitCommitProcessor:\n    \n    def __init__(self):\n        self.repo = git.Repo()\n    \n    def extract_code_changes(self):\n        diff = self.repo.git.diff('--cached')\n        return diff\n    \n    def tokenize_changes(self, code_changes):\n        tokens = nltk.word_tokenize(code_changes)\n        return tokens\n    \n    def analyze_changes(self, tokens):\n        # Perform NLP analysis to identify keywords, context, and sentiment\n        # Return the analyzed data\n        pass\n    \n    def generate_commit_message(self, analyzed_data):\n        # Generate a proposed commit message based on the analyzed data\n        return \"Proposed commit message\"\n    \n    def display_commit_message(self, commit_message):\n        # Display the proposed commit message to the user\n        # Allow the user to accept or reject the message\n        # Return user's decision\n        pass\n    \n    def stage_and_commit(self, code_changes, commit_message):\n        if commit_message:\n            self.repo.git.add(update=True)\n            self.repo.git.commit(m=commit_message)\n    \n    def handle_error(self, error_message):\n        # Display appropriate error message to the user\n        # Allow user to retry NLP analysis or provide custom commit message\n        pass\n\nif __name__ == \"__main__\":\n    # Usage example\n    processor = GitCommitProcessor()\n    code_changes = processor.extract_code_changes()\n    tokens = processor.tokenize_changes(code_changes)\n    analyzed_data = processor.analyze_changes(tokens)\n    commit_message = processor.generate_commit_message(analyzed_data)\n    user_decision = processor.display_commit_message(commit_message)\n\n    if user_decision == \"accept\":\n        processor.stage_and_commit(code_changes, commit_message)\n    elif user_decision == \"reject\":\n        custom_message = input(\"Enter custom commit message: \")\n        processor.stage_and_commit(code_changes, custom_message)"
    }
]