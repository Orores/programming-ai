[
    {
        "role": "system",
        "content": "You are a programm that creates a similiar python class method based on a provided class method and a short description and nothing else."
    },
    {
        "role": "user",
        "content": "Create a similiar class method to the following code, but instead of creating a seperate json for each subdirectory, the new method shall create a single json, the directory names shall be the new keys and for each directory key the value shall be a list of dictionaries just like before.\n\n    def convert_directories_to_json(self):\n        \"\"\"\n        Converts subdirectories containing 'role_i.txt' and 'content_i.txt' files into JSON objects.\n\n        The method reads 'role_i.txt' and 'content_i.txt' files within each subdirectory of the input directory.\n        It constructs JSON objects representing the subdirectory's content, where each object contains 'role' and 'content' keys.\n        The JSON objects are then saved as separate files in the output directory.\n\n        Input:\n        - None (Operates on the instance's input_directory and output_directory attributes)\n\n        Output:\n        - Creates JSON files in the output directory, each representing a subdirectory's content.\n          Each JSON file contains an array of objects with 'role' and 'content' keys:\n          [\n              {\"role\": \"role_1_string\", \"content\": \"content_1_string\"},\n              {\"role\": \"role_2_string\", \"content\": \"content_2_string\"},\n              ...\n          ]\n\n        Raises:\n        - No explicit exceptions are raised within this method.\n        \"\"\"\n\n        if not os.path.exists(self.output_directory):\n            os.makedirs(self.output_directory)\n\n        for subdir in os.listdir(self.input_directory):\n            subdir_path = os.path.join(self.input_directory, subdir)\n            \n            roles_contents = []\n            for i in range(1, 1000): # Assuming up to 1000 subdirectories\n                role_file_1 = os.path.join(subdir_path, f'role_{i}.txt')\n                content_file_1 = os.path.join(subdir_path, f'content_{i}.txt')\n                role_file_2 = os.path.join(subdir_path, f'role{i}.txt')\n                content_file_2 = os.path.join(subdir_path, f'content{i}.txt')\n                \n                if not (os.path.exists(role_file_1) and os.path.exists(content_file_1)) and not (os.path.exists(role_file_2) and os.path.exists(content_file_2)):\n                    break\n                \n                role_file = role_file_1 if os.path.exists(role_file_1) else role_file_2\n                content_file = content_file_1 if os.path.exists(content_file_1) else content_file_2\n                \n                with open(role_file, 'r') as role_fp, open(content_file, 'r') as content_fp:\n                    role_content = {\"role\": role_fp.read().strip(), \"content\": content_fp.read().strip()}\n                    roles_contents.append(role_content)\n            \n            output_json_file = os.path.join(self.output_directory, f'{subdir}.json')\n            with open(output_json_file, 'w') as json_fp:\n                json.dump(roles_contents, json_fp, indent=4)"
    },
    {
        "role": "assistant",
        "content": "def convert_directories_to_single_json(self):\n        \"\"\"\n        Converts subdirectories containing 'role_i.txt' and 'content_i.txt' files into a single JSON object.\n\n        The method reads 'role_i.txt' and 'content_i.txt' files within each subdirectory of the input directory.\n        It constructs a single JSON object with directory names as keys and a list of dictionaries as values.\n        Each dictionary represents the content of a subdirectory, containing 'role' and 'content' keys.\n\n        Input:\n        - None (Operates on the instance's input_directory and output_directory attributes)\n\n        Output:\n        - Creates a single JSON file in the output directory, representing all subdirectories.\n          The JSON file contains directory names as keys, and each value is an array of objects with 'role' and 'content' keys:\n          {\n              \"subdirectory1\": [\n                  {\"role\": \"role_1_string\", \"content\": \"content_1_string\"},\n                  {\"role\": \"role_2_string\", \"content\": \"content_2_string\"},\n                  ...\n              ],\n              \"subdirectory2\": [\n                  ...\n              ],\n              ...\n          }\n\n        Raises:\n        - No explicit exceptions are raised within this method.\n        \"\"\"\n\n        if not os.path.exists(self.output_directory):\n            os.makedirs(self.output_directory)\n\n        directory_data = {}\n\n        for subdir in os.listdir(self.input_directory):\n            subdir_path = os.path.join(self.input_directory, subdir)\n            \n            roles_contents = []\n            for i in range(1, 1000): # Assuming up to 1000 subdirectories\n                role_file_1 = os.path.join(subdir_path, f'role_{i}.txt')\n                content_file_1 = os.path.join(subdir_path, f'content_{i}.txt')\n                role_file_2 = os.path.join(subdir_path, f'role{i}.txt')\n                content_file_2 = os.path.join(subdir_path, f'content{i}.txt')\n                \n                if not (os.path.exists(role_file_1) and os.path.exists(content_file_1)) and not (os.path.exists(role_file_2) and os.path.exists(content_file_2)):\n                    break\n                \n                role_file = role_file_1 if os.path.exists(role_file_1) else role_file_2\n                content_file = content_file_1 if os.path.exists(content_file_1) else content_file_2\n                \n                with open(role_file, 'r') as role_fp, open(content_file, 'r') as content_fp:\n                    role_content = {\"role\": role_fp.read().strip(), \"content\": content_fp.read().strip()}\n                    roles_contents.append(role_content)\n            \n            directory_data[subdir] = roles_contents\n\n        output_json_file = os.path.join(self.output_directory, 'all_directories.json')\n        with open(output_json_file, 'w') as json_fp:\n            json.dump(directory_data, json_fp, indent=4)"
    }
]