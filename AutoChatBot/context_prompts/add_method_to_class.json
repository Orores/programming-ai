[
    {
        "role": "system",
        "content": "you are a programm that extends python classes by a method and nothing else"
    },
    {
        "role": "user",
        "content": "add a new method to the class which decides whether the use the to_json or to_json_single method based on a new class parameter called \"json_mode\", which can be \"single\" or \"multiple\"\n\nimport os\nimport json\n\nclass DirectoryToJsonConverter:\n    \"\"\"\n    The code takes a directory specified by the `input_directory` variable as input. Within this directory, there are subdirectories containing files named `role_i` and `content_i`, where `i` ranges from 1 to `n`.\n\n    The Class can handle names that are either role_{i}.txt or role{i}.txt\n\n    The goal is to transform each subdirectory into a JSON object with the subdirectory's name. Each JSON object will contain an array of objects structured as follows:\n\n\n    ```\n    [\n        {\"role\": \"role_1_string\", \"content\": \"content_1_string\"},\n        {\"role\": \"role_2_string\", \"content\": \"content_2_string\"},\n        ...\n    ]\n    ```\n\n    This transformation should be applied to each subdirectory up to `n`. The resulting JSON objects will be saved to a directory specified by the `output_directory` variable.\n    \"\"\"\n\n    def __init__(self, input_directory, output_directory):\n        self.input_directory = input_directory\n        self.output_directory = output_directory\n\n    def convert_directories_to_json(self):\n        \"\"\"\n        Converts subdirectories containing 'role_i.txt' and 'content_i.txt' files into JSON objects.\n\n        The method reads 'role_i.txt' and 'content_i.txt' files within each subdirectory of the input directory.\n        It constructs JSON objects representing the subdirectory's content, where each object contains 'role' and 'content' keys.\n        The JSON objects are then saved as separate files in the output directory.\n\n        Input:\n        - None (Operates on the instance's input_directory and output_directory attributes)\n\n        Output:\n        - Creates JSON files in the output directory, each representing a subdirectory's content.\n          Each JSON file contains an array of objects with 'role' and 'content' keys:\n          [\n              {\"role\": \"role_1_string\", \"content\": \"content_1_string\"},\n              {\"role\": \"role_2_string\", \"content\": \"content_2_string\"},\n              ...\n          ]\n\n        Raises:\n        - No explicit exceptions are raised within this method.\n        \"\"\"\n\n        if not os.path.exists(self.output_directory):\n            os.makedirs(self.output_directory)\n\n        for subdir in os.listdir(self.input_directory):\n            subdir_path = os.path.join(self.input_directory, subdir)\n            \n            roles_contents = []\n            for i in range(1, 1000): # Assuming up to 1000 subdirectories\n                role_file_1 = os.path.join(subdir_path, f'role_{i}.txt')\n                content_file_1 = os.path.join(subdir_path, f'content_{i}.txt')\n                role_file_2 = os.path.join(subdir_path, f'role{i}.txt')\n                content_file_2 = os.path.join(subdir_path, f'content{i}.txt')\n                \n                if not (os.path.exists(role_file_1) and os.path.exists(content_file_1)) and not (os.path.exists(role_file_2) and os.path.exists(content_file_2)):\n                    break\n                \n                role_file = role_file_1 if os.path.exists(role_file_1) else role_file_2\n                content_file = content_file_1 if os.path.exists(content_file_1) else content_file_2\n                \n                with open(role_file, 'r') as role_fp, open(content_file, 'r') as content_fp:\n                    role_content = {\"role\": role_fp.read().strip(), \"content\": content_fp.read().strip()}\n                    roles_contents.append(role_content)\n            \n            output_json_file = os.path.join(self.output_directory, f'{subdir}.json')\n            with open(output_json_file, 'w') as json_fp:\n                json.dump(roles_contents, json_fp, indent=4)\n\n    def convert_directories_to_single_json(self):\n            \"\"\"\n            Converts subdirectories containing 'role_i.txt' and 'content_i.txt' files into a single JSON object.\n\n            The method reads 'role_i.txt' and 'content_i.txt' files within each subdirectory of the input directory.\n            It constructs a single JSON object with directory names as keys and a list of dictionaries as values.\n            Each dictionary represents the content of a subdirectory, containing 'role' and 'content' keys.\n\n            Input:\n            - None (Operates on the instance's input_directory and output_directory attributes)\n\n            Output:\n            - Creates a single JSON file in the output directory, representing all subdirectories.\n              The JSON file contains directory names as keys, and each value is an array of objects with 'role' and 'content' keys:\n              {\n                  \"subdirectory1\": [\n                      {\"role\": \"role_1_string\", \"content\": \"content_1_string\"},\n                      {\"role\": \"role_2_string\", \"content\": \"content_2_string\"},\n                      ...\n                  ],\n                  \"subdirectory2\": [\n                      ...\n                  ],\n                  ...\n              }\n\n            Raises:\n            - No explicit exceptions are raised within this method.\n            \"\"\"\n\n            if not os.path.exists(self.output_directory):\n                os.makedirs(self.output_directory)\n\n            directory_data = {}\n\n            for subdir in os.listdir(self.input_directory):\n                subdir_path = os.path.join(self.input_directory, subdir)\n                \n                roles_contents = []\n                for i in range(1, 1000): # Assuming up to 1000 subdirectories\n                    role_file_1 = os.path.join(subdir_path, f'role_{i}.txt')\n                    content_file_1 = os.path.join(subdir_path, f'content_{i}.txt')\n                    role_file_2 = os.path.join(subdir_path, f'role{i}.txt')\n                    content_file_2 = os.path.join(subdir_path, f'content{i}.txt')\n                    \n                    if not (os.path.exists(role_file_1) and os.path.exists(content_file_1)) and not (os.path.exists(role_file_2) and os.path.exists(content_file_2)):\n                        break\n                    \n                    role_file = role_file_1 if os.path.exists(role_file_1) else role_file_2\n                    content_file = content_file_1 if os.path.exists(content_file_1) else content_file_2\n                    \n                    with open(role_file, 'r') as role_fp, open(content_file, 'r') as content_fp:\n                        role_content = {\"role\": role_fp.read().strip(), \"content\": content_fp.read().strip()}\n                        roles_contents.append(role_content)\n                \n                directory_data[subdir] = roles_contents\n\n            output_json_file = os.path.join(self.output_directory, 'all_directories.json')\n            with open(output_json_file, 'w') as json_fp:\n                json.dump(directory_data, json_fp, indent=4)\n\n# Example usage\nif __name__ == '__main__':\n    input_directory = 'raw_context'\n    output_directory = 'context_prompts'\n\n    converter = DirectoryToJsonConverter(input_directory, output_directory)\n    converter.convert_directories_to_json()"
    },
    {
        "role": "assistant",
        "content": "added method:\n    def convert_directories_to_json_based_on_mode(self):\n        \"\"\"\n        Converts subdirectories containing 'role_i.txt' and 'content_i.txt' files into JSON objects based on the json_mode parameter.\n\n        The method reads 'role_i.txt' and 'content_i.txt' files within each subdirectory of the input directory.\n        It constructs JSON objects representing the subdirectory's content, where each object contains 'role' and 'content' keys.\n        The JSON objects are then saved as separate files in the output directory if json_mode is 'multiple'.\n        If json_mode is 'single', a single JSON file representing all subdirectories will be created.\n\n        Input:\n        - json_mode: A string indicating the mode to determine the JSON conversion method ('single' or 'multiple')\n\n        Output:\n        - Creates JSON files in the output directory if json_mode is 'multiple', each representing a subdirectory's content.\n          Each JSON file contains an array of objects with 'role' and 'content' keys:\n          [\n              {\"role\": \"role_1_string\", \"content\": \"content_1_string\"},\n              {\"role\": \"role_2_string\", \"content\": \"content_2_string\"},\n              ...\n          ]\n        - Creates a single JSON file in the output directory if json_mode is 'single', representing all subdirectories.\n          The JSON file contains directory names as keys, and each value is an array of objects with 'role' and 'content' keys:\n          {\n              \"subdirectory1\": [\n                  {\"role\": \"role_1_string\", \"content\": \"content_1_string\"},\n                  {\"role\": \"role_2_string\", \"content\": \"content_2_string\"},\n                  ...\n              ],\n              \"subdirectory2\": [\n                  ...\n              ],\n              ...\n          }\n\n        Raises:\n        - No explicit exceptions are raised within this method.\n        \"\"\"\n\n        if json_mode == 'multiple':\n            self.convert_directories_to_json()\n        elif json_mode == 'single':\n            self.convert_directories_to_single_json()\n        else:\n            print(\"Invalid json_mode. Please use 'single' or 'multiple'.\")\n\nold init method:\n    def __init__(self, input_directory, output_directory):\n        self.input_directory = input_directory\n        self.output_directory = output_directory\n\nnew init method:\n    def __init__(self, input_directory, output_directory, json_mode):\n        self.input_directory = input_directory\n        self.output_directory = output_directory\n        self.json_mode = json_mode\n\nold example usage:\n# Example usage\nif __name__ == '__main__':\n    input_directory = 'raw_context'\n    output_directory = 'context_prompts'\n\n    converter = DirectoryToJsonConverter(input_directory, output_directory)\n \nnew example usage:\n# Example usage\nif __name__ == '__main__':\n    input_directory = 'raw_context'\n    output_directory = 'context_prompts'\n    json_mode = 'single'\n\n    converter = DirectoryToJsonConverter(input_directory, output_directory, json_mode)"
    }
]